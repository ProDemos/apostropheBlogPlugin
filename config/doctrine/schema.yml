options:
  type: INNODB

aBlogItem:
  actAs:
    Timestampable: ~
    Taggable: ~
    Sluggable: ~
    Commentable: ~
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    author_id:
      type: integer(4)
    page_id:
      type: integer(4)
    title:
      type: string(255)
      notnull: true
    excerpt:
      type: string
    status:
      type: enum
      values: [draft, pending review, published ]
      notnull: true
      default: draft
    allow_comments:
      type: boolean
      notnull: true
      default: 0
    template:
      type: string(255)
      default: singleColumnTemplate
  relations:
    Author:
      class: sfGuardUser
      foreignAlias: BlogAuthorItems
      local: author_id
      foreign: id
      onDelete: SET NULL
    Editors:
      foreignAlias: BlogEditorItems
      class: sfGuardUser
      refClass: aBlogEditor
      local: blog_item_id
      foreign: user_id
    Page:
      class: aPage
      local: page_id
      foreign: id
      onDelete: CASCADE
    Categories:
      foreignAlias: BlogItems
      class: aBlogCategory
      refClass: aBlogItemCategory
      local: blog_item_id
      foreign: blog_category_id
      
      
aBlogEditor:
  columns:
    blog_item_id: 
      type: integer
      primary: true
    user_id:
      type: integer(4)
      primary: true
  relations:
    BlogItem:
      foreignAlias: BlogItemEditors
      class: aBlogItem
      local: blog_item_id
    Editor:
      foreignAlias: BlogItemEditors
      class: sfGuardUser
      local: user_id
      
aBlogItemCategory:
  columns:
    blog_item_id:
      type: integer
      primary: true
    blog_category_id:
      type: integer(4)
      primary: true
  relations:
    BlogItem:
      foreignAlias: BlogItemCategories
      class: aBlogItem
      local: blog_item_id
    BlogCategory:
      foreignAlias: BlogItemCategories
      class: aBlogCategory
      local: blog_category_id
      
aBlogCategory:
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    name:
      type: string(255)
      unique: true
    description:
      type: string
  relations:
    Users:
      foreignAlias: BlogCategories
      class: sfGuardUser
      refClass: aBlogCategoryUser
      local: blog_category_id
      foreign: user_id
    BlogItems:
      foreignAlias: BlogCategories
      class: aBlogItem
      refClass: aBlogItemCategory
      local: blog_category_id
      foreign: blog_item_id
    Pages:
      class: aPage
      local: blog_category_id
      foreign: page_id
      foreignAlias: BlogCategories
      refClass: aBlogPageCategory
      
aBlogPageCategory:
  tableName: a_blog_page_category
  options:
    symfony:
      form:   false
      filter: false
  columns:
    page_id:
      type: integer(4)
      primary: true
    blog_category_id:
      type: integer(4)
      primary: true
  relations:
    aBlogCategory:
      local: blog_category_id
      onDelete: CASCADE
    aPage:
      local: page_id
      onDelete: CASCADE
          
aBlogCategoryUser:
  columns:
    blog_category_id:
      type: integer(4)
      primary: true
    user_id:
      type: integer(4)
      primary: true
  relations:
    BlogCategory:
      foreignAlias: BlogCategoryUsers
      class: aBlogCategory
      local: blog_category_id
    User:
      foreignAlias: BlogCategoryUsers
      class: sfGuardUser
      local: user_id
    
aBlogPost:
  inheritance:
    extends: aBlogItem
    type: column_aggregation
    keyField: type
    keyValue: 'post'
  columns:
    published_at:
      type: timestamp
      
aBlogSlot:
  inheritance:
    extends: aSlot
    type: column_aggregation
    keyField: type
    keyValue: 'aBlog'
      
aBlogSlotSlot:
  # Doctrine doesn't produce useful forms with column aggregation inheritance anyway,
  # and slots often use serialization into the value column... the Doctrine forms are not
  # of much use here and they clutter the project
  options:
    symfony:
      form:   false
      filter: false

  # columns:
  #
  # You can add columns here. However, if you do not need foreign key relationships it is
  # often easier to store your data in the 'value' column via serialize(). If you do add columns, 
  # their names must be unique across all slots in your project, so use a unique prefix 
  # for your company.
    
  # This is how we are able to retrieve slots of various types with a single query from
  # a single table
  inheritance:
    extends: aSlot
    type: column_aggregation
    keyField: type
    keyValue: 'aBlogSlot'
